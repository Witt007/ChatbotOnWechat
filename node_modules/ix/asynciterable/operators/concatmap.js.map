{"version":3,"sources":["asynciterable/operators/concatmap.ts"],"names":[],"mappings":";;;AAAA,sDAAuE;AAEvE,2CAA4C;AAC5C,iDAAkD;AAElD,sDAAkD;AAElD,MAAM,sBAAyC,SAAQ,+BAAuB;IAElE;IACA;IACA;IAHV,YACU,OAA+B,EAC/B,SAAsD,EACtD,QAAc;QAEtB,KAAK,EAAE,CAAC;QAJA,YAAO,GAAP,OAAO,CAAwB;QAC/B,cAAS,GAAT,SAAS,CAA6C;QACtD,aAAQ,GAAR,QAAQ,CAAM;IAGxB,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,IAAA,2BAAc,EAAC,MAAM,CAAC,CAAC;QACvB,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;QACxD,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI,IAAA,yBAAa,EAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE;YAC7D,MAAM,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,UAAU,EAAE,EAAE,MAAM,CAAC,CAAC;YACnE,MAAM,MAAM,GAAG,CAAC,IAAA,sBAAS,EAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,MAAM,CAAC,CAAC,CAAC,MAAM,CAAgC,CAAC;YAC1F,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI,IAAA,yBAAa,EAAC,+BAAc,CAAC,EAAE,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,EAAE;gBAC1E,MAAM,KAAK,CAAC;aACb;SACF;IACH,CAAC;CACF;AAED;;;;;;;;;;;;;;GAcG;AACH,SAAgB,SAAS,CACvB,QAAqD,EACrD,OAAa;IAEb,OAAO,SAAS,yBAAyB,CAAC,MAAM;QAC9C,OAAO,IAAI,sBAAsB,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;IAC/D,CAAC,CAAC;AACJ,CAAC;AAPD,8BAOC","file":"concatmap.js","sourcesContent":["import { AsyncIterableInput, AsyncIterableX } from '../asynciterablex';\nimport { OperatorAsyncFunction } from '../../interfaces';\nimport { wrapWithAbort } from './withabort';\nimport { throwIfAborted } from '../../aborterror';\nimport { FlattenConcurrentSelector } from './_flatten';\nimport { isPromise } from '../../util/isiterable';\n\nclass ConcatMapAsyncIterable<TSource, TResult> extends AsyncIterableX<TResult> {\n  constructor(\n    private _source: AsyncIterable<TSource>,\n    private _selector: FlattenConcurrentSelector<TSource, TResult>,\n    private _thisArg?: any\n  ) {\n    super();\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    let outerIndex = 0;\n    const { _thisArg: thisArg, _selector: selector } = this;\n    for await (const outer of wrapWithAbort(this._source, signal)) {\n      const result = selector.call(thisArg, outer, outerIndex++, signal);\n      const values = (isPromise(result) ? await result : result) as AsyncIterableInput<TResult>;\n      for await (const inner of wrapWithAbort(AsyncIterableX.as(values), signal)) {\n        yield inner;\n      }\n    }\n  }\n}\n\n/**\n * Projects each element of an async-iterable sequence to an async-iterable sequence and merges\n * the resulting async-iterable sequences into one async-iterable sequence.\n *\n * @template TSource The type of the elements in the source sequence.\n * @template TResult The type of the elements in the projected inner sequences and the elements in the merged result sequence.\n * @param {((\n *     value: TSource,\n *     index: number,\n *     signal?: AbortSignal\n *   ) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>)} selector A transform function to apply to each element.\n * @param {*} [thisArg] Option this for binding to the selector.\n * @returns {OperatorAsyncFunction<TSource, TResult>} An operator that creates an async-iterable sequence whose\n * elements are the result of invoking the one-to-many transform function on each element of the input sequence.\n */\nexport function concatMap<TSource, TResult>(\n  selector: FlattenConcurrentSelector<TSource, TResult>,\n  thisArg?: any\n): OperatorAsyncFunction<TSource, TResult> {\n  return function concatMapOperatorFunction(source) {\n    return new ConcatMapAsyncIterable(source, selector, thisArg);\n  };\n}\n"]}