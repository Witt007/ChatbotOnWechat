{"version":3,"sources":["asynciterable/operators/_flatten.ts"],"names":[],"mappings":"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","file":"_flatten.js","sourcesContent":["import { AsyncIterableInput, AsyncIterableX } from '../asynciterablex';\nimport { wrapWithAbort } from '../operators/withabort';\nimport { AbortError, throwIfAborted } from '../../aborterror';\nimport { safeRace } from '../../util/safeRace';\nimport { isPromise } from '../../util/isiterable';\n\nexport type FlattenConcurrentSelector<TSource, TResult> = (\n  value: TSource,\n  index: number,\n  signal?: AbortSignal\n) => Promise<AsyncIterableInput<TResult>> | AsyncIterableInput<TResult>;\n\nconst NEVER_PROMISE = new Promise<IteratorResult<never>>(() => {});\n\nconst enum Type {\n  OUTER = 0,\n  INNER = 1,\n}\n\nfunction ignoreInnerAbortErrors(signal: AbortSignal) {\n  return function ignoreInnerAbortError(e?: any) {\n    if (signal.aborted && e instanceof AbortError) {\n      return NEVER_PROMISE;\n    }\n    throw e;\n  };\n}\n\nasync function* wrapIterator<T>(\n  source: AsyncIterable<T>,\n  index: number,\n  type: Type,\n  signal?: AbortSignal\n) {\n  for await (const value of wrapWithAbort(source, signal)) {\n    throwIfAborted(signal);\n    yield { type, index, value };\n  }\n  return { type, index, value: undefined };\n}\n\nexport class FlattenConcurrentAsyncIterable<TSource, TResult> extends AsyncIterableX<TResult> {\n  constructor(\n    private _source: AsyncIterable<TSource>,\n    private _selector: FlattenConcurrentSelector<TSource, TResult>,\n    private _concurrent: number,\n    private _switchMode: boolean,\n    private _thisArg?: any\n  ) {\n    super();\n    this._concurrent = this._switchMode ? 1 : Math.max(_concurrent, 1);\n  }\n  async *[Symbol.asyncIterator](outerSignal?: AbortSignal) {\n    throwIfAborted(outerSignal);\n\n    type OuterWrapper = { value: TSource; index: number; type: Type.OUTER };\n    type InnerWrapper = { value: TResult; index: number; type: Type.INNER };\n\n    let active = 0;\n    let outerIndex = 0;\n    let outerComplete = false;\n\n    const thisArg = this._thisArg;\n    const selector = this._selector;\n    const switchMode = this._switchMode;\n    const concurrent = this._concurrent;\n\n    const outerValues = new Array<TSource>(0);\n    const innerIndices = new Array<number>(0);\n    const controllers = new Array<AbortController>(isFinite(concurrent) ? concurrent : 0);\n    const inners = new Array<AsyncGenerator<InnerWrapper>>(isFinite(concurrent) ? concurrent : 0);\n\n    const outer = wrapIterator(this._source, 0, Type.OUTER, outerSignal) as AsyncGenerator<\n      OuterWrapper\n    >;\n    const results = [outer.next()] as Promise<IteratorResult<OuterWrapper | InnerWrapper>>[];\n\n    try {\n      while (1) {\n        const {\n          done = false,\n          value: { type, value, index },\n        } = await safeRace(results);\n\n        if (!done) {\n          switch (type) {\n            case Type.OUTER: {\n              if (switchMode) {\n                active = 0;\n              }\n              if (active < concurrent) {\n                pullNextOuter(value as TSource);\n              } else {\n                outerValues.push(value as TSource);\n              }\n              results[0] = outer.next();\n              break;\n            }\n            case Type.INNER: {\n              yield value as TResult;\n              results[index] = pullNextInner(index);\n              break;\n            }\n          }\n        } else {\n          // ignore this result slot\n          results[index] = NEVER_PROMISE;\n          switch (type) {\n            case Type.OUTER:\n              outerComplete = true;\n              break;\n            case Type.INNER:\n              --active;\n              // return the current slot to the pool\n              innerIndices.push(index);\n              // synchronously drain the `outerValues` buffer\n              while (active < concurrent && outerValues.length) {\n                // Don't use `await` so we avoid blocking while the number of active inner sequences is less than `concurrent`.\n                pullNextOuter(outerValues.shift()!);\n              }\n              break;\n          }\n          if (outerComplete && active + outerValues.length === 0) {\n            return;\n          }\n        }\n      }\n    } finally {\n      controllers.forEach((controller) => {\n        controller?.abort();\n      });\n    }\n\n    function pullNextInner(index: number) {\n      const result = inners[index - 1].next();\n      const { [index - 1]: controller } = controllers;\n      return result.catch(ignoreInnerAbortErrors(controller.signal));\n    }\n\n    function pullNextOuter(outerValue: TSource) {\n      ++active;\n\n      const index = innerIndices.pop() || active;\n\n      // abort the current inner iterator first\n      if (switchMode && controllers[index - 1]) {\n        controllers[index - 1].abort();\n      }\n\n      controllers[index - 1] = new AbortController();\n      const innerSignal = controllers[index - 1].signal;\n\n      // Get the next inner sequence.\n      // `selector` is a sync or async function that returns AsyncIterableInput.\n      const inner = selector.call(thisArg, outerValue, outerIndex++, innerSignal);\n\n      const wrapAndPullInner = (inner: AsyncIterableInput<TResult> | TResult) => {\n        inners[index - 1] = wrapIterator(\n          AsyncIterableX.as(inner),\n          index,\n          Type.INNER,\n          innerSignal\n        ) as AsyncGenerator<InnerWrapper>;\n        return pullNextInner(index);\n      };\n\n      results[index] = isPromise(inner)\n        ? (inner.then(wrapAndPullInner) as Promise<IteratorResult<InnerWrapper, any>>)\n        : wrapAndPullInner(inner);\n    }\n  }\n}\n"]}