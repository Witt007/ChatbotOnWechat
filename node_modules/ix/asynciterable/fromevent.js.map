{"version":3,"sources":["asynciterable/fromevent.ts"],"names":[],"mappings":";;;AACA,yDAAsD;AACtD,mDAAgD;AAwBhD,SAAS,yBAAyB,CAAC,GAAQ;IACzC,OAAO,CAAC,CAAC,GAAG,IAAI,IAAA,uBAAU,EAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAA,uBAAU,EAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAC5D,CAAC;AAED,SAAS,kBAAkB,CAAC,GAAQ;IAClC,OAAO,CAAC,CAAC,GAAG,IAAI,IAAA,uBAAU,EAAC,GAAG,CAAC,WAAW,CAAC,IAAI,IAAA,uBAAU,EAAC,GAAG,CAAC,cAAc,CAAC,CAAC;AAChF,CAAC;AAED,SAAS,aAAa,CAAC,GAAQ;IAC7B,OAAO,CAAC,CAAC,GAAG,IAAI,IAAA,uBAAU,EAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,IAAA,uBAAU,EAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC;AAC1F,CAAC;AAoBD;;;;;;;;;GASG;AACH,SAAgB,SAAS,CACvB,GAAkB,EAClB,IAAY,EACZ,OAA8D,EAC9D,cAA4C;IAE5C,IAAI,IAAA,uBAAU,EAAC,OAAO,CAAC,EAAE;QACvB,cAAc,GAAG,OAAO,CAAC;QACzB,OAAO,GAAG,SAAS,CAAC;KACrB;IAED,IAAI,aAAa,CAAC,GAAG,CAAC,EAAE;QACtB,MAAM,MAAM,GAAgB,GAAG,CAAC;QAChC,OAAO,IAAA,mCAAgB,EACrB,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,EAAiB,CAAC,EAAE,OAA+B,CAAC,EACvF,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,mBAAmB,CAAC,IAAI,EAAiB,CAAC,EAAE,OAA+B,CAAC,EAC1F,cAAc,CACf,CAAC;KACH;SAAM,IAAI,yBAAyB,CAAC,GAAG,CAAC,EAAE;QACzC,MAAM,MAAM,GAAsB,GAAG,CAAC;QACtC,OAAO,IAAA,mCAAgB,EACrB,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,EACzB,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,EAC1B,cAAc,CACf,CAAC;KACH;SAAM,IAAI,kBAAkB,CAAC,GAAG,CAAC,EAAE;QAClC,MAAM,MAAM,GAAqB,GAAG,CAAC;QACrC,OAAO,IAAA,mCAAgB,EACrB,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,CAAC,EAClC,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC,EACrC,cAAc,CACf,CAAC;KACH;SAAM;QACL,MAAM,IAAI,SAAS,CAAC,0BAA0B,CAAC,CAAC;KACjD;AACH,CAAC;AAnCD,8BAmCC","file":"fromevent.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { fromEventPattern } from './fromeventpattern';\nimport { isFunction } from '../util/isiterable';\n\ntype CommonEventHandler = (...args: any[]) => void;\n\nexport interface OnOffEventEmitter {\n  on(event: string | symbol, listener: CommonEventHandler): this;\n  off(event: string | symbol, listener: CommonEventHandler): this;\n}\n\nexport interface NodeEventEmitter {\n  addListener(event: string | symbol, listener: CommonEventHandler): this;\n  removeListener(event: string | symbol, listener: CommonEventHandler): this;\n}\n\nexport type EventListenerOptions =\n  | {\n      capture?: boolean;\n      passive?: boolean;\n      once?: boolean;\n    }\n  | boolean;\n\nexport type EventedTarget = EventTarget | OnOffEventEmitter | NodeEventEmitter;\n\nfunction isMessagePortEventEmitter(obj: any): obj is OnOffEventEmitter {\n  return !!obj && isFunction(obj.on) && isFunction(obj.off);\n}\n\nfunction isNodeEventEmitter(obj: any): obj is NodeEventEmitter {\n  return !!obj && isFunction(obj.addListener) && isFunction(obj.removeListener);\n}\n\nfunction isEventTarget(obj: any): obj is EventTarget {\n  return !!obj && isFunction(obj.addEventListener) && isFunction(obj.removeEventListener);\n}\n\nexport function fromEvent<TSource>(obj: EventedTarget, eventName: string): AsyncIterableX<TSource>;\nexport function fromEvent<TSource>(\n  obj: EventedTarget,\n  eventName: string,\n  resultSelector: (...args: any[]) => TSource\n): AsyncIterableX<TSource>;\nexport function fromEvent<TSource>(\n  obj: EventedTarget,\n  eventName: string,\n  options: EventListenerOptions\n): AsyncIterableX<TSource>;\nexport function fromEvent<TSource>(\n  obj: EventedTarget,\n  eventName: string,\n  options: EventListenerOptions,\n  resultSelector: (...args: any[]) => TSource\n): AsyncIterableX<TSource>;\n\n/**\n * Converts an event emitter event into an async-iterable stream.\n *\n * @template TSource The type of elements in the emitter stream.\n * @param {EventedTarget} obj The object that emits the events to turn into an async-iterable.\n * @param {string} type The name of the event to listen for creation of the async-iterable.\n * @param {EventListenerOptions} [options] The options for listening to the events such as capture, passive and once.\n * @param {(...args: any[]) => TSource} [resultSelector] The result selector for the event.\n * @returns {AsyncIterableX<TSource>} An async-iterable sequence created from the events emitted from the evented target.\n */\nexport function fromEvent<TSource>(\n  obj: EventedTarget,\n  type: string,\n  options?: EventListenerOptions | ((...args: any[]) => TSource),\n  resultSelector?: (...args: any[]) => TSource\n): AsyncIterableX<TSource> {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n\n  if (isEventTarget(obj)) {\n    const target = <EventTarget>obj;\n    return fromEventPattern<TSource>(\n      (h) => target.addEventListener(type, <EventListener>h, options as EventListenerOptions),\n      (h) => target.removeEventListener(type, <EventListener>h, options as EventListenerOptions),\n      resultSelector\n    );\n  } else if (isMessagePortEventEmitter(obj)) {\n    const target = <OnOffEventEmitter>obj;\n    return fromEventPattern<TSource>(\n      (h) => target.on(type, h),\n      (h) => target.off(type, h),\n      resultSelector\n    );\n  } else if (isNodeEventEmitter(obj)) {\n    const target = <NodeEventEmitter>obj;\n    return fromEventPattern<TSource>(\n      (h) => target.addListener(type, h),\n      (h) => target.removeListener(type, h),\n      resultSelector\n    );\n  } else {\n    throw new TypeError('Unsupported event target');\n  }\n}\n"]}