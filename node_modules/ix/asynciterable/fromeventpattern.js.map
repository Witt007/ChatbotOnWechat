{"version":3,"sources":["asynciterable/fromeventpattern.ts"],"names":[],"mappings":";;;AAAA,iDAA8C;AAC9C,+CAA4C;AAC5C,mDAAgD;AAEhD,2CAAwC;AAExC,MAAM,EAAE,OAAO,EAAE,GAAG,KAAK,CAAC;AAE1B,SAAS,WAAW,CAAO,EAAyB,EAAE,IAAa;IACjE,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;AAChD,CAAC;AAED;;;;;;;GAOG;AACH,SAAgB,gBAAgB,CAC9B,UAAuD,EACvD,aAA0D,EAC1D,cAA4C;IAE5C,IAAI,CAAC,IAAA,uBAAU,EAAC,cAAc,CAAC,EAAE;QAC/B,cAAc,GAAG,mBAAQ,CAAC;KAC3B;IAED,MAAM,IAAI,GAAG,IAAI,qBAAS,EAAW,CAAC;IACtC,MAAM,OAAO,GAAG,CAAC,GAAG,IAAW,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,cAAe,EAAE,IAAI,CAAC,CAAC,CAAC;IAEnF,UAAU,CAAC,OAAO,CAAC,CAAC;IAEpB,MAAM,IAAI,GAAG,KAAK,SAAS,CAAC;QAC1B,IAAI;YACF,KAAK,IAAI,IAAI,EAAE,CAAC,CAAC,IAAI,GAAG,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,GAAI;gBACjD,MAAM,IAAI,CAAC,KAAK,CAAC;aAClB;SACF;gBAAS;YACR,aAAa,CAAC,OAAO,CAAC,CAAC;YACvB,IAAI,CAAC,GAAG,EAAE,CAAC;SACZ;IACH,CAAC,CAAC;IAEF,OAAO,IAAA,iBAAO,GAAW,CAAC,IAAI,EAAE,CAAC,CAAC;AACpC,CAAC;AA1BD,4CA0BC","file":"fromeventpattern.js","sourcesContent":["import { memoize } from './operators/memoize';\nimport { identity } from '../util/identity';\nimport { isFunction } from '../util/isiterable';\nimport { AsyncIterableX } from './asynciterablex';\nimport { AsyncSink } from './asyncsink';\n\nconst { isArray } = Array;\n\nfunction callOrApply<T, R>(fn: (...values: T[]) => R, args: T | T[]): R {\n  return isArray(args) ? fn(...args) : fn(args);\n}\n\n/**\n * Creates async-iterable from an event emitter by adding handlers for both listening and unsubscribing from events.\n *\n * @template TSource The type of elements in the event emitter.\n * @param {(handler: (...args: any[]) => void) => void} addHandler The function to add a listener to the source.\n * @param {(handler: (...args: any[]) => void) => void} removeHandler The function to remove a listener from the source.\n * @returns {AsyncIterableX<TSource>} An async-iterable which contains the data from the underlying events as wrapped by the handlers.\n */\nexport function fromEventPattern<TSource>(\n  addHandler: (handler: (...args: any[]) => void) => void,\n  removeHandler: (handler: (...args: any[]) => void) => void,\n  resultSelector?: (...args: any[]) => TSource\n): AsyncIterableX<TSource> {\n  if (!isFunction(resultSelector)) {\n    resultSelector = identity;\n  }\n\n  const sink = new AsyncSink<TSource>();\n  const handler = (...args: any[]) => sink.write(callOrApply(resultSelector!, args));\n\n  addHandler(handler);\n\n  const loop = async function* () {\n    try {\n      for (let next; !(next = await sink.next()).done; ) {\n        yield next.value;\n      }\n    } finally {\n      removeHandler(handler);\n      sink.end();\n    }\n  };\n\n  return memoize<TSource>()(loop());\n}\n"]}