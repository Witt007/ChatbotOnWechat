"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromEventPattern = void 0;
const memoize_1 = require("./operators/memoize");
const identity_1 = require("../util/identity");
const isiterable_1 = require("../util/isiterable");
const asyncsink_1 = require("./asyncsink");
const { isArray } = Array;
function callOrApply(fn, args) {
    return isArray(args) ? fn(...args) : fn(args);
}
/**
 * Creates async-iterable from an event emitter by adding handlers for both listening and unsubscribing from events.
 *
 * @template TSource The type of elements in the event emitter.
 * @param {(handler: (...args: any[]) => void) => void} addHandler The function to add a listener to the source.
 * @param {(handler: (...args: any[]) => void) => void} removeHandler The function to remove a listener from the source.
 * @returns {AsyncIterableX<TSource>} An async-iterable which contains the data from the underlying events as wrapped by the handlers.
 */
function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (!(0, isiterable_1.isFunction)(resultSelector)) {
        resultSelector = identity_1.identity;
    }
    const sink = new asyncsink_1.AsyncSink();
    const handler = (...args) => sink.write(callOrApply(resultSelector, args));
    addHandler(handler);
    const loop = async function* () {
        try {
            for (let next; !(next = await sink.next()).done;) {
                yield next.value;
            }
        }
        finally {
            removeHandler(handler);
            sink.end();
        }
    };
    return (0, memoize_1.memoize)()(loop());
}
exports.fromEventPattern = fromEventPattern;

//# sourceMappingURL=fromeventpattern.js.map
