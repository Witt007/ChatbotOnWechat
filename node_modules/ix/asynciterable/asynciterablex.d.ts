/// <reference types="node" />
import { OperatorAsyncFunction, UnaryFunction } from '../interfaces';
import { Observable } from '../observer';
/**
 * This class serves as the base for all operations which support [Symbol.asyncIterator].
 */
export declare abstract class AsyncIterableX<T> implements AsyncIterable<T> {
    abstract [Symbol.asyncIterator](signal?: AbortSignal): AsyncIterator<T>;
    /** @nocollapse */
    forEach(projection: (value: T, index: number, signal?: AbortSignal) => void | Promise<void>, thisArg?: any, signal?: AbortSignal): Promise<void>;
    /** @nocollapse */
    pipe<R>(...operations: UnaryFunction<AsyncIterable<T>, R>[]): R;
    pipe<R>(...operations: OperatorAsyncFunction<T, R>[]): AsyncIterableX<R>;
    pipe<R extends NodeJS.WritableStream>(writable: R, options?: {
        end?: boolean;
    }): R;
    /** @nocollapse */
    static from<TSource, TResult = TSource>(source: AsyncIterableInput<TSource>, selector?: (value: TSource, index: number) => TResult | Promise<TResult>, thisArg?: any): AsyncIterableX<TResult>;
    /**
     * Converts an existing string into an async-iterable of characters.
     *
     * @param {string} source The string to convert to an async-iterable.
     * @returns {AsyncIterableX<string>} An async-iterable stream of characters from the source.
     */
    static as(source: string): AsyncIterableX<string>;
    /**
     * Converts the async iterable like input into an async-iterable.
     *
     * @template T The type of elements in the async-iterable like sequence.
     * @param {AsyncIterableInput<T>} source The async-iterable like input to convert to an async-iterable.
     * @returns {AsyncIterableX<T>} An async-iterable stream from elements in the async-iterable like sequence.
     */
    static as<T>(source: AsyncIterableInput<T>): AsyncIterableX<T>;
    /**
     * Converts the single element into an async-iterable sequence.
     *
     * @template T The type of the input to turn into an async-iterable sequence.
     * @param {T} source The single element to turn into an async-iterable sequence.
     * @returns {AsyncIterableX<T>} An async-iterable sequence which contains the single element.
     */
    static as<T>(source: T): AsyncIterableX<T>;
}
export declare class AsyncSink<TSource> implements AsyncIterableIterator<TSource> {
    private _ended;
    private _values;
    private _resolvers;
    constructor();
    [Symbol.asyncIterator](): this;
    write(value: TSource): void;
    error(error: any): void;
    private _push;
    next(): Promise<IteratorReturnResult<any> | IteratorYieldResult<TSource>>;
    end(): void;
}
export declare class FromArrayIterable<TSource, TResult = TSource> extends AsyncIterableX<TResult> {
    private _source;
    private _selector;
    constructor(source: ArrayLike<TSource>, selector: (value: TSource, index: number) => TResult | Promise<TResult>);
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<TResult>, void, unknown>;
}
export declare class FromAsyncIterable<TSource, TResult = TSource> extends AsyncIterableX<TResult> {
    private _source;
    private _selector;
    constructor(source: Iterable<TSource | PromiseLike<TSource>> | AsyncIterable<TSource>, selector: (value: TSource, index: number) => TResult | Promise<TResult>);
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<TResult>, void, unknown>;
}
export declare class FromPromiseIterable<TSource, TResult = TSource> extends AsyncIterableX<TResult> {
    private _source;
    private _selector;
    constructor(source: PromiseLike<TSource>, selector: (value: TSource, index: number) => TResult | Promise<TResult>);
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<TResult>, void, unknown>;
}
export declare class FromObservableAsyncIterable<TSource, TResult = TSource> extends AsyncIterableX<TResult> {
    private _observable;
    private _selector;
    constructor(observable: Observable<TSource>, selector: (value: TSource, index: number) => TResult | Promise<TResult>);
    [Symbol.asyncIterator](signal?: AbortSignal): AsyncGenerator<Awaited<TResult>, void, unknown>;
}
export declare type AsyncIterableInput<TSource> = AsyncIterable<TSource> | AsyncIterator<TSource> | Iterable<TSource | PromiseLike<TSource>> | ArrayLike<TSource> | PromiseLike<TSource> | Observable<TSource>;
declare module '../asynciterable/asynciterablex' {
    interface AsyncIterableX<T> {
        pipe(): AsyncIterableX<T>;
        pipe<A>(op1: OperatorAsyncFunction<T, A>): AsyncIterableX<A>;
        pipe<A, B>(op1: OperatorAsyncFunction<T, A>, op2: OperatorAsyncFunction<A, B>): AsyncIterableX<B>;
        pipe<A, B, C>(op1: OperatorAsyncFunction<T, A>, op2: OperatorAsyncFunction<A, B>, op3: OperatorAsyncFunction<B, C>): AsyncIterableX<C>;
        pipe<A, B, C, D>(op1: OperatorAsyncFunction<T, A>, op2: OperatorAsyncFunction<A, B>, op3: OperatorAsyncFunction<B, C>, op4: OperatorAsyncFunction<C, D>): AsyncIterableX<D>;
        pipe<A, B, C, D, E>(op1: OperatorAsyncFunction<T, A>, op2: OperatorAsyncFunction<A, B>, op3: OperatorAsyncFunction<B, C>, op4: OperatorAsyncFunction<C, D>, op5: OperatorAsyncFunction<D, E>): AsyncIterableX<E>;
        pipe<A, B, C, D, E, F>(op1: OperatorAsyncFunction<T, A>, op2: OperatorAsyncFunction<A, B>, op3: OperatorAsyncFunction<B, C>, op4: OperatorAsyncFunction<C, D>, op5: OperatorAsyncFunction<D, E>, op6: OperatorAsyncFunction<E, F>): AsyncIterableX<F>;
        pipe<A, B, C, D, E, F, G>(op1: OperatorAsyncFunction<T, A>, op2: OperatorAsyncFunction<A, B>, op3: OperatorAsyncFunction<B, C>, op4: OperatorAsyncFunction<C, D>, op5: OperatorAsyncFunction<D, E>, op6: OperatorAsyncFunction<E, F>, op7: OperatorAsyncFunction<F, G>): AsyncIterableX<G>;
        pipe<A, B, C, D, E, F, G, H>(op1: OperatorAsyncFunction<T, A>, op2: OperatorAsyncFunction<A, B>, op3: OperatorAsyncFunction<B, C>, op4: OperatorAsyncFunction<C, D>, op5: OperatorAsyncFunction<D, E>, op6: OperatorAsyncFunction<E, F>, op7: OperatorAsyncFunction<F, G>, op8: OperatorAsyncFunction<G, H>): AsyncIterableX<H>;
        pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorAsyncFunction<T, A>, op2: OperatorAsyncFunction<A, B>, op3: OperatorAsyncFunction<B, C>, op4: OperatorAsyncFunction<C, D>, op5: OperatorAsyncFunction<D, E>, op6: OperatorAsyncFunction<E, F>, op7: OperatorAsyncFunction<F, G>, op8: OperatorAsyncFunction<G, H>, op9: OperatorAsyncFunction<H, I>): AsyncIterableX<I>;
        pipe(...operations: OperatorAsyncFunction<any, any>[]): AsyncIterableX<any>;
        pipe<A extends NodeJS.WritableStream>(op1: A, options?: {
            end?: boolean;
        }): A;
    }
}
