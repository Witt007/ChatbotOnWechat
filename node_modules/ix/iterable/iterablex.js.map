{"version":3,"sources":["iterable/iterablex.ts"],"names":[],"mappings":"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","file":"iterablex.js","sourcesContent":["import { identity } from '../util/identity';\nimport { UnaryFunction, OperatorFunction } from '../interfaces';\nimport { bindCallback } from '../util/bindcallback';\nimport {\n  isArrayLike,\n  isIterable,\n  isIterator,\n  isReadableNodeStream,\n  isWritableNodeStream,\n} from '../util/isiterable';\nimport { toLength } from '../util/tolength';\n\n/**\n * This class serves as the base for all operations which support [Symbol.iterator].\n */\nexport abstract class IterableX<T> implements Iterable<T> {\n  abstract [Symbol.iterator](): Iterator<T>;\n\n  /** @nocollapse */\n  forEach(projection: (value: T, index: number) => void, thisArg?: any): void {\n    const fn = bindCallback(projection, thisArg, 2);\n    let i = 0;\n    for (const item of this) {\n      fn(item, i++);\n    }\n  }\n\n  /** @nocollapse */\n  pipe<R>(...operations: UnaryFunction<Iterable<T>, R>[]): R;\n  pipe<R>(...operations: OperatorFunction<T, R>[]): IterableX<R>;\n  pipe<R extends NodeJS.WritableStream>(writable: R, options?: { end?: boolean }): R;\n  pipe<R>(...args: any[]) {\n    let i = -1;\n    const n = args.length;\n    let acc: any = this;\n    while (++i < n) {\n      acc = args[i](IterableX.as(acc));\n    }\n    return acc;\n  }\n\n  /**\n   * Converts an existing string into an iterable of characters.\n   *\n   * @param {string} source The string to convert to an iterable.\n   * @returns {IterableX<string>} An terable stream of characters from the source.\n   */\n  static as(source: string): IterableX<string>;\n  /**\n   * Converts the iterable like input into an iterable.\n   *\n   * @template T The tyep of elements in the source iterable.\n   * @param {Iterable<T>} source The iterable to convert to an iterable.\n   * @returns {IterableX<T>} An iterable stream of the source sequence.\n   */\n  static as<T>(source: Iterable<T>): IterableX<T>;\n  /**\n   * Converts an array-like object to an iterable.\n   *\n   * @template T The type of elements in the source array-like sequence.\n   * @param {ArrayLike<T>} source The array-like sequence to convert to an iterable.\n   * @returns {IterableX<T>} The iterable containing the elements from the array-like sequence.\n   */\n  static as<T>(source: ArrayLike<T>): IterableX<T>;\n  /**\n   * Converts the object into a singleton in an iterable sequence.\n   *\n   * @template T The type of element to turn into an iterable sequence.\n   * @param {T} source The item to turn into an iterable sequence.\n   * @returns {IterableX<T>} An iterable sequence from the source object.\n   */\n  static as<T>(source: T): IterableX<T>;\n  /** @nocollapse */\n  static as(source: any) {\n    if (source instanceof IterableX) {\n      return source;\n    }\n    if (typeof source === 'string') {\n      return new FromIterable([source], identity);\n    }\n    if (isIterable(source) || isArrayLike(source)) {\n      return new FromIterable(source, identity);\n    }\n\n    return new FromIterable([source], identity);\n  }\n\n  /** @nocollapse */\n  static from<TSource, TResult = TSource>(\n    source: Iterable<TSource> | Iterator<TSource> | ArrayLike<TSource>,\n    selector: (value: TSource, index: number) => TResult = identity,\n    thisArg?: any\n  ): IterableX<TResult> {\n    const fn = bindCallback(selector, thisArg, 2);\n    if (isIterable(source)) {\n      return new FromIterable<TSource, TResult>(source, fn);\n    }\n    if (isArrayLike(source)) {\n      return new FromIterable<TSource, TResult>(source, fn);\n    }\n    if (isIterator(source)) {\n      return new FromIterable<TSource, TResult>({ [Symbol.iterator]: () => source }, fn);\n    }\n    throw new TypeError('Input type not supported');\n  }\n}\n\n(<any>IterableX.prototype)[Symbol.toStringTag] = 'IterableX';\n\nObject.defineProperty(IterableX, Symbol.hasInstance, {\n  writable: true,\n  configurable: true,\n  value(inst: any) {\n    return !!(inst && inst[Symbol.toStringTag] === 'IterableX');\n  },\n});\n\nexport class FromIterable<TSource, TResult = TSource> extends IterableX<TResult> {\n  private _source: Iterable<TSource> | ArrayLike<TSource>;\n  private _fn: (value: TSource, index: number) => TResult;\n\n  constructor(\n    source: Iterable<TSource> | ArrayLike<TSource>,\n    fn: (value: TSource, index: number) => TResult\n  ) {\n    super();\n    this._source = source;\n    this._fn = fn;\n  }\n\n  *[Symbol.iterator]() {\n    const iterable = isIterable(this._source);\n    let i = 0;\n    if (iterable) {\n      for (const item of <Iterable<TSource>>this._source) {\n        yield this._fn(item, i++);\n      }\n    } else {\n      const length = toLength((<ArrayLike<TSource>>this._source).length);\n      while (i < length) {\n        const val = (<ArrayLike<TSource>>this._source)[i];\n        yield this._fn(val, i++);\n      }\n    }\n  }\n}\n\ntype WritableOrOperatorFunction<T, R> =\n  | NodeJS.WritableStream\n  | NodeJS.ReadWriteStream\n  | OperatorFunction<T, R>;\n\ndeclare module '../iterable/iterablex' {\n  interface IterableX<T> extends Iterable<T> {\n    pipe(): IterableX<T>;\n    pipe<A>(op1: OperatorFunction<T, A>): IterableX<A>;\n    pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): IterableX<B>;\n    pipe<A, B, C>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>\n    ): IterableX<C>;\n    pipe<A, B, C, D>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>\n    ): IterableX<D>;\n    pipe<A, B, C, D, E>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>\n    ): IterableX<E>;\n    pipe<A, B, C, D, E, F>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>\n    ): IterableX<F>;\n    pipe<A, B, C, D, E, F, G>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>\n    ): IterableX<G>;\n    pipe<A, B, C, D, E, F, G, H>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>,\n      op8: OperatorFunction<G, H>\n    ): IterableX<H>;\n    pipe<A, B, C, D, E, F, G, H, I>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>,\n      op8: OperatorFunction<G, H>,\n      op9: OperatorFunction<H, I>\n    ): IterableX<I>;\n    pipe<R>(...operations: OperatorFunction<T, R>[]): IterableX<R>;\n    pipe<A extends NodeJS.WritableStream>(op1: A, options?: { end?: boolean }): A;\n  }\n}\n\ntry {\n  ((isBrowser) => {\n    if (isBrowser) {\n      return;\n    }\n\n    IterableX.prototype['pipe'] = nodePipe;\n    const readableOpts = (x: any, opts = x._writableState || { objectMode: true }) => opts;\n\n    function nodePipe<T>(this: IterableX<T>, ...args: any[]) {\n      let i = -1;\n      let end: boolean;\n      const n = args.length;\n      let prev: any = this;\n      let next: WritableOrOperatorFunction<T, any>;\n      while (++i < n) {\n        next = args[i];\n        if (typeof next === 'function') {\n          prev = next(IterableX.as(prev));\n        } else if (isWritableNodeStream(next)) {\n          ({ end = true } = args[i + 1] || {});\n          // prettier-ignore\n          return isReadableNodeStream(prev) ? prev.pipe(next, { end }) :\n            IterableX.as(prev).toNodeStream(readableOpts(next)).pipe(next, { end });\n        }\n      }\n      return prev;\n    }\n  })(typeof window === 'object' && typeof document === 'object' && document.nodeType === 9);\n} catch (e) {\n  /* */\n}\n"]}