"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromIterable = exports.IterableX = void 0;
const identity_1 = require("../util/identity");
const bindcallback_1 = require("../util/bindcallback");
const isiterable_1 = require("../util/isiterable");
const tolength_1 = require("../util/tolength");
/**
 * This class serves as the base for all operations which support [Symbol.iterator].
 */
class IterableX {
    /** @nocollapse */
    forEach(projection, thisArg) {
        const fn = (0, bindcallback_1.bindCallback)(projection, thisArg, 2);
        let i = 0;
        for (const item of this) {
            fn(item, i++);
        }
    }
    pipe(...args) {
        let i = -1;
        const n = args.length;
        let acc = this;
        while (++i < n) {
            acc = args[i](IterableX.as(acc));
        }
        return acc;
    }
    /** @nocollapse */
    static as(source) {
        if (source instanceof IterableX) {
            return source;
        }
        if (typeof source === 'string') {
            return new FromIterable([source], identity_1.identity);
        }
        if ((0, isiterable_1.isIterable)(source) || (0, isiterable_1.isArrayLike)(source)) {
            return new FromIterable(source, identity_1.identity);
        }
        return new FromIterable([source], identity_1.identity);
    }
    /** @nocollapse */
    static from(source, selector = identity_1.identity, thisArg) {
        const fn = (0, bindcallback_1.bindCallback)(selector, thisArg, 2);
        if ((0, isiterable_1.isIterable)(source)) {
            return new FromIterable(source, fn);
        }
        if ((0, isiterable_1.isArrayLike)(source)) {
            return new FromIterable(source, fn);
        }
        if ((0, isiterable_1.isIterator)(source)) {
            return new FromIterable({ [Symbol.iterator]: () => source }, fn);
        }
        throw new TypeError('Input type not supported');
    }
}
exports.IterableX = IterableX;
IterableX.prototype[Symbol.toStringTag] = 'IterableX';
Object.defineProperty(IterableX, Symbol.hasInstance, {
    writable: true,
    configurable: true,
    value(inst) {
        return !!(inst && inst[Symbol.toStringTag] === 'IterableX');
    },
});
class FromIterable extends IterableX {
    _source;
    _fn;
    constructor(source, fn) {
        super();
        this._source = source;
        this._fn = fn;
    }
    *[Symbol.iterator]() {
        const iterable = (0, isiterable_1.isIterable)(this._source);
        let i = 0;
        if (iterable) {
            for (const item of this._source) {
                yield this._fn(item, i++);
            }
        }
        else {
            const length = (0, tolength_1.toLength)(this._source.length);
            while (i < length) {
                const val = this._source[i];
                yield this._fn(val, i++);
            }
        }
    }
}
exports.FromIterable = FromIterable;
try {
    ((isBrowser) => {
        if (isBrowser) {
            return;
        }
        IterableX.prototype['pipe'] = nodePipe;
        const readableOpts = (x, opts = x._writableState || { objectMode: true }) => opts;
        function nodePipe(...args) {
            let i = -1;
            let end;
            const n = args.length;
            let prev = this;
            let next;
            while (++i < n) {
                next = args[i];
                if (typeof next === 'function') {
                    prev = next(IterableX.as(prev));
                }
                else if ((0, isiterable_1.isWritableNodeStream)(next)) {
                    ({ end = true } = args[i + 1] || {});
                    // prettier-ignore
                    return (0, isiterable_1.isReadableNodeStream)(prev) ? prev.pipe(next, { end }) :
                        IterableX.as(prev).toNodeStream(readableOpts(next)).pipe(next, { end });
                }
            }
            return prev;
        }
    })(typeof window === 'object' && typeof document === 'object' && document.nodeType === 9);
}
catch (e) {
    /* */
}

//# sourceMappingURL=iterablex.js.map
