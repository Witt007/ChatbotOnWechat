/// <reference types="node" />
import { UnaryFunction, OperatorFunction } from '../interfaces';
/**
 * This class serves as the base for all operations which support [Symbol.iterator].
 */
export declare abstract class IterableX<T> implements Iterable<T> {
    abstract [Symbol.iterator](): Iterator<T>;
    /** @nocollapse */
    forEach(projection: (value: T, index: number) => void, thisArg?: any): void;
    /** @nocollapse */
    pipe<R>(...operations: UnaryFunction<Iterable<T>, R>[]): R;
    pipe<R>(...operations: OperatorFunction<T, R>[]): IterableX<R>;
    pipe<R extends NodeJS.WritableStream>(writable: R, options?: {
        end?: boolean;
    }): R;
    /**
     * Converts an existing string into an iterable of characters.
     *
     * @param {string} source The string to convert to an iterable.
     * @returns {IterableX<string>} An terable stream of characters from the source.
     */
    static as(source: string): IterableX<string>;
    /**
     * Converts the iterable like input into an iterable.
     *
     * @template T The tyep of elements in the source iterable.
     * @param {Iterable<T>} source The iterable to convert to an iterable.
     * @returns {IterableX<T>} An iterable stream of the source sequence.
     */
    static as<T>(source: Iterable<T>): IterableX<T>;
    /**
     * Converts an array-like object to an iterable.
     *
     * @template T The type of elements in the source array-like sequence.
     * @param {ArrayLike<T>} source The array-like sequence to convert to an iterable.
     * @returns {IterableX<T>} The iterable containing the elements from the array-like sequence.
     */
    static as<T>(source: ArrayLike<T>): IterableX<T>;
    /**
     * Converts the object into a singleton in an iterable sequence.
     *
     * @template T The type of element to turn into an iterable sequence.
     * @param {T} source The item to turn into an iterable sequence.
     * @returns {IterableX<T>} An iterable sequence from the source object.
     */
    static as<T>(source: T): IterableX<T>;
    /** @nocollapse */
    static from<TSource, TResult = TSource>(source: Iterable<TSource> | Iterator<TSource> | ArrayLike<TSource>, selector?: (value: TSource, index: number) => TResult, thisArg?: any): IterableX<TResult>;
}
export declare class FromIterable<TSource, TResult = TSource> extends IterableX<TResult> {
    private _source;
    private _fn;
    constructor(source: Iterable<TSource> | ArrayLike<TSource>, fn: (value: TSource, index: number) => TResult);
    [Symbol.iterator](): Generator<TResult, void, unknown>;
}
declare module '../iterable/iterablex' {
    interface IterableX<T> extends Iterable<T> {
        pipe(): IterableX<T>;
        pipe<A>(op1: OperatorFunction<T, A>): IterableX<A>;
        pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): IterableX<B>;
        pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): IterableX<C>;
        pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): IterableX<D>;
        pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): IterableX<E>;
        pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): IterableX<F>;
        pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): IterableX<G>;
        pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): IterableX<H>;
        pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): IterableX<I>;
        pipe<R>(...operations: OperatorFunction<T, R>[]): IterableX<R>;
        pipe<A extends NodeJS.WritableStream>(op1: A, options?: {
            end?: boolean;
        }): A;
    }
}
